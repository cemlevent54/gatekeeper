import { Injectable, OnModuleInit, Type } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Permission, PermissionDocument } from '../../schemas/permission.schema';
import { PERMISSIONS_KEY } from '../decorators/permissions.decorator';

// Controller'larƒ± manuel import et
import { UserController } from '../../modules/user/controllers/user.controller';
import { AuthController } from '../../modules/auth/controllers/auth.controller';
import { RolesController } from '../../modules/roles/controllers/roles.controller';
import { PermissionsController } from '../../modules/permissions/controllers/permissions.controller';

@Injectable()
export class PermissionSeederService implements OnModuleInit {
    constructor(
        @InjectModel(Permission.name) private permissionModel: Model<PermissionDocument>,
    ) { }

    async onModuleInit() {
        console.log('[PermissionSeeder] Uygulama ba≈ülatƒ±lƒ±yor, permission\'lar kontrol ediliyor...');
        await this.seedPermissions();
    }

    /**
     * Controller'lardan gerekli permission'larƒ± √ßƒ±karƒ±r ve veritabanƒ±na ekler
     */
    private async seedPermissions(): Promise<void> {
        try {
            // Controller'lardan gerekli permission'larƒ± al
            const requiredPermissions = await this.getRequiredPermissions();

            console.log(`[PermissionSeeder] Toplam ${requiredPermissions.length} permission kontrol edilecek:`);
            requiredPermissions.forEach(p => console.log(`  - ${p.key}: ${p.description}`));

            let createdCount = 0;
            let updatedCount = 0;
            let existingCount = 0;

            for (const permissionData of requiredPermissions) {
                const result = await this.ensurePermissionExists(permissionData);
                if (result === 'created') createdCount++;
                else if (result === 'updated') updatedCount++;
                else if (result === 'existing') existingCount++;
            }

            console.log(`[PermissionSeeder] ƒ∞≈ülem tamamlandƒ±:`);
            console.log(`  - Yeni olu≈üturulan: ${createdCount}`);
            console.log(`  - G√ºncellenen: ${updatedCount}`);
            console.log(`  - Zaten mevcut: ${existingCount}`);
            console.log(`  - Toplam: ${createdCount + updatedCount + existingCount}`);
        } catch (error) {
            console.error('[PermissionSeeder] Permission\'lar eklenirken hata:', error);
        }
    }

    /**
     * Controller'lardan otomatik olarak permission'larƒ± √ßƒ±karƒ±r
     */
    private async getRequiredPermissions(): Promise<{ key: string; description: string }[]> {
        try {
            // Controller'larƒ± ke≈üfet
            console.log('[PermissionSeeder] üîç Controller\'lar ke≈üfediliyor...');
            const controllers = this.discoverControllers();

            if (controllers.length === 0) {
                console.warn('[PermissionSeeder] ‚ö†Ô∏è Hi√ß controller ke≈üfedilemedi!');
                return [];
            }

            console.log(`[PermissionSeeder] üìã ${controllers.length} controller analiz ediliyor...`);

            // Her controller'ƒ± detaylƒ± analiz et
            const allPermissions: string[] = [];
            for (const controller of controllers) {
                try {
                    const analysis = this.analyzeController(controller);
                    console.log(`[PermissionSeeder] üìã ${analysis.controllerName}:`);

                    analysis.methods.forEach(method => {
                        if (method.permissions.length > 0) {
                            console.log(`  - ${method.methodName}: ${method.permissions.join(', ')}`);
                        }
                    });

                    allPermissions.push(...analysis.allPermissions);
                } catch (error) {
                    console.error(`[PermissionSeeder] ‚ùå ${controller.name} analiz edilemedi:`, error);
                }
            }

            // Permission'larƒ± kategorize et
            const categorized = this.categorizePermissions(allPermissions);

            // Her kategori i√ßin wildcard permission'ƒ± ekle
            for (const category of Object.keys(categorized)) {
                const wildcardPermission = `${category}.*`;
                if (!allPermissions.includes(wildcardPermission)) {
                    allPermissions.push(wildcardPermission);
                    console.log(`[PermissionSeeder] ‚ûï Wildcard permission eklendi: ${wildcardPermission}`);
                }
            }

            // Permission'larƒ± description'larla birlikte d√∂nd√ºr
            const result = allPermissions.map(permission => ({
                key: permission,
                description: this.generateDescription(permission)
            }));

            console.log(`[PermissionSeeder] üîç Toplam ${result.length} permission tespit edildi`);
            return result;
        } catch (error) {
            console.error('[PermissionSeeder] Permission\'lar √ßƒ±karƒ±lƒ±rken hata:', error);
            return [];
        }
    }

    /**
     * T√ºm controller'larƒ± ke≈üfeder
     */
    private discoverControllers(): Type<any>[] {
        const controllers: Type<any>[] = [
            UserController,
            AuthController,
            RolesController,
            PermissionsController,
        ];

        console.log(`[PermissionSeeder] ${controllers.length} controller y√ºklendi:`);
        controllers.forEach(controller => {
            console.log(`  - ${controller.name}`);
        });

        return controllers;
    }

    /**
     * Belirtilen controller'dan t√ºm permission'larƒ± √ßƒ±karƒ±r
     */
    private getPermissionsFromController(controllerClass: Type<any>): string[] {
        const permissions: string[] = [];

        // Controller'ƒ±n prototype'ƒ±ndaki t√ºm method'larƒ± al
        const prototype = controllerClass.prototype;
        const methodNames = Object.getOwnPropertyNames(prototype);

        for (const methodName of methodNames) {
            if (methodName === 'constructor') continue;

            const method = prototype[methodName];
            if (typeof method !== 'function') continue;

            // Method'un metadata'sƒ±ndan permission'larƒ± al
            const methodPermissions = Reflect.getMetadata(PERMISSIONS_KEY, method);
            if (methodPermissions && Array.isArray(methodPermissions)) {
                permissions.push(...methodPermissions);
            }
        }

        return [...new Set(permissions)]; // Duplicate'larƒ± kaldƒ±r
    }

    /**
     * Permission'larƒ± kategorize eder (user.*, admin.*, vb.)
     */
    private categorizePermissions(permissions: string[]): { [category: string]: string[] } {
        const categorized: { [category: string]: string[] } = {};

        for (const permission of permissions) {
            const parts = permission.split('.');
            if (parts.length >= 2) {
                const category = parts[0];
                if (!categorized[category]) {
                    categorized[category] = [];
                }
                categorized[category].push(permission);
            }
        }

        return categorized;
    }

    /**
     * Permission'dan a√ßƒ±klama olu≈üturur
     */
    private generateDescription(permission: string): string {
        const parts = permission.split('.');

        if (parts.length === 1) {
            return `${parts[0]} i≈ülemleri izni`;
        }

        const [category, action] = parts;

        const actionDescriptions: { [key: string]: string } = {
            'view': 'g√∂r√ºnt√ºleme',
            'create': 'olu≈üturma',
            'edit': 'd√ºzenleme',
            'update': 'g√ºncelleme',
            'delete': 'silme',
            'upload': 'y√ºkleme',
            'download': 'indirme',
            'export': 'dƒ±≈üa aktarma',
            'import': 'i√ße aktarma',
            'manage': 'y√∂netme',
            'configure': 'yapƒ±landƒ±rma',
            'approve': 'onaylama',
            'reject': 'reddetme',
            'activate': 'aktifle≈ütirme',
            'deactivate': 'pasifle≈ütirme',
        };

        const categoryDescriptions: { [key: string]: string } = {
            'user': 'kullanƒ±cƒ±',
            'admin': 'admin',
            'role': 'rol',
            'permission': 'izin',
            'system': 'sistem',
            'report': 'rapor',
            'audit': 'denetim',
            'backup': 'yedekleme',
            'settings': 'ayarlar',
            'dashboard': 'dashboard',
        };

        const categoryDesc = categoryDescriptions[category] || category;
        const actionDesc = actionDescriptions[action] || action;

        if (action === '*') {
            return `T√ºm ${categoryDesc} i≈ülemleri izni`;
        }

        return `${categoryDesc} ${actionDesc} izni`;
    }

    /**
     * Controller'ƒ±n t√ºm method'larƒ±nƒ± ve permission'larƒ±nƒ± detaylƒ± olarak analiz eder
     */
    private analyzeController(controllerClass: Type<any>): {
        controllerName: string;
        methods: Array<{
            methodName: string;
            permissions: string[];
        }>;
        allPermissions: string[];
    } {
        const controllerName = controllerClass.name;
        const methods: Array<{ methodName: string; permissions: string[] }> = [];
        const allPermissions: string[] = [];

        const prototype = controllerClass.prototype;
        const methodNames = Object.getOwnPropertyNames(prototype);

        for (const methodName of methodNames) {
            if (methodName === 'constructor') continue;

            const method = prototype[methodName];
            if (typeof method !== 'function') continue;

            const methodPermissions = Reflect.getMetadata(PERMISSIONS_KEY, method) || [];
            methods.push({
                methodName,
                permissions: methodPermissions
            });
            allPermissions.push(...methodPermissions);
        }

        return {
            controllerName,
            methods,
            allPermissions: [...new Set(allPermissions)]
        };
    }

    /**
     * Belirtilen permission'ƒ±n veritabanƒ±nda var olup olmadƒ±ƒüƒ±nƒ± kontrol eder
     * Yoksa olu≈üturur, varsa g√ºnceller
     * @returns 'created' | 'updated' | 'existing'
     */
    private async ensurePermissionExists(permissionData: { key: string; description: string }): Promise<'created' | 'updated' | 'existing'> {
        try {
            const existingPermission = await this.permissionModel.findOne({
                key: permissionData.key,
                isDeleted: false
            });

            if (!existingPermission) {
                // Permission yoksa olu≈ütur
                const newPermission = new this.permissionModel({
                    key: permissionData.key,
                    description: permissionData.description,
                    isActive: true,
                    isDeleted: false,
                    createdAt: new Date(),
                    updatedAt: new Date()
                });

                await newPermission.save();
                console.log(`[PermissionSeeder] ‚úÖ YENƒ∞ OLU≈ûTURULDU: ${permissionData.key} - ${permissionData.description}`);
                return 'created';
            } else {
                // Permission varsa a√ßƒ±klamasƒ±nƒ± g√ºncelle (eƒüer farklƒ±ysa)
                if (existingPermission.description !== permissionData.description) {
                    existingPermission.description = permissionData.description;
                    (existingPermission as any).updatedAt = new Date();
                    await existingPermission.save();
                    console.log(`[PermissionSeeder] üîÑ G√úNCELLENDƒ∞: ${permissionData.key} - ${permissionData.description}`);
                    return 'updated';
                } else {
                    console.log(`[PermissionSeeder] ‚úÖ ZATEN MEVCUT: ${permissionData.key} - ${permissionData.description}`);
                    return 'existing';
                }
            }
        } catch (error) {
            console.error(`[PermissionSeeder] ‚ùå HATA (${permissionData.key}):`, error);
            throw error;
        }
    }

    /**
     * Manuel olarak permission eklemek i√ßin public method
     */
    public async addPermission(key: string, description: string): Promise<void> {
        await this.ensurePermissionExists({ key, description });
    }

    /**
     * T√ºm permission'larƒ± yeniden kontrol etmek i√ßin
     */
    public async reseedPermissions(): Promise<void> {
        console.log('[PermissionSeeder] Permission\'lar yeniden ekleniyor...');
        await this.seedPermissions();
    }
}
